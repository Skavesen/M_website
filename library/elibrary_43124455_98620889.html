<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>elibrary_43124455_98620889</title><meta name="author" content="пк"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .p, p { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; margin:0pt; }
 h1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 .a, a { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s2 { color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 h2 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s3 { color: black; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: "- "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)") "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: "- "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: "- "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l5 {padding-left: 0pt; }
 #l5> li>*:first-child:before {content: "- "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l6 {padding-left: 0pt;counter-reset: f1 1; }
 #l6> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l6> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l7 {padding-left: 0pt;counter-reset: f2 1; }
 #l7> li>*:first-child:before {counter-increment: f2; content: counter(f2, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l7> li:first-child>*:first-child:before {counter-increment: f2 0;  }
</style></head><body><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">УДК 004</p><h1 style="padding-top: 6pt;padding-left: 204pt;text-indent: -191pt;text-align: left;">Обзор алгоритмов аутентификации в распределенных программных системах</h1><p style="padding-top: 5pt;padding-left: 172pt;text-indent: 0pt;text-align: left;">Грищенко О.С., Чернышова А.В.</p><p style="padding-left: 168pt;text-indent: -57pt;text-align: left;"><a href="mailto:alla@donntu.org" class="a" target="_blank">Донецкий национальный технический университет, г. Донецк Кафедра программной инженерии alla@donntu.org,</a><a href="mailto:olleg1996@mail.ru" class="a" target="_blank"> </a><a href="mailto:olleg1996@mail.ru" target="_blank">olleg1996@mail.ru</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Постановка задачи</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 35pt;text-align: justify;">Аутентификация является важной частью любой распределенной программной системы. На сегодняшний день существует несколько основных подходов к аутентификации в программных системах и множество вариантов реализации этих подходов. Не все алгоритмы аутентификации обеспечивают одинаковый уровень защищенности и обычно имеют свою область применения. В связи с этим было решено рассмотреть алгоритмы и протоколы аутентификации, которые используются в современных распределенных программных системах, оценить их достоинства и недостатки.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Цель работы</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 35pt;text-align: justify;">Целью данной работы является анализ подходов к аутентификации в программных системах, рассмотрение принципов работы алгоритмов аутентификации, используемых в современных распределенных программных системах, исследование существующих стандартов в области аутентификации.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Основные способы аутентификации</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 35pt;text-align: justify;">Наиболее простым способом аутентификации является аутентификация по паролю. При регистрации на ресурсе пользователь задает свой логин (имя, телефон, email) и пароль. При аутентификации необходимо проверить соответствие логина и пароля. Такой способ аутентификации дает достаточно слабый уровень защиты. Прежде всего, пользователь сам задает и хранит пароль. При этом пароль может быть коротким (так что его можно будет легко подобрать простым перебором) или предсказуемым. Например, по состоянию на 2016 год в результате исследования 10000000 пользовательских паролей было выяснено, что самыми популярными являются такие пароли как &quot;123456&quot;, &quot;123456789&quot;, &quot;qwerty&quot;, &quot;12345678&quot;. Причем пароль &quot;123456&quot; использовали 17% пользователей [1]. Взлом таких паролей с помощью современных инструментов подбора паролей займет не более нескольких секунд.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Можно добиться большей защищенности путем использования специальных генераторов паролей, с помощью регулярной смены пароля и за счет использования различных паролей для разных ресурсов. Можно выделить требования к системам, реализующим аутентификацию пользователя по паролю, которые помогут значительно повысить защищенность таких систем:</p><ul id="l1"><li><p style="padding-left: 47pt;text-indent: -5pt;line-height: 11pt;text-align: justify;">приложение не должно позволять создавать простые пароли;</p></li><li><p style="padding-left: 47pt;text-indent: -5pt;line-height: 12pt;text-align: justify;">приложение должно предусматривать защиту от перебора паролей;</p></li><li><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">если в процессе работы приложения пароль передается по сети, то при передаче должно использоваться защищенное соединение;</p></li><li><p style="padding-left: 47pt;text-indent: -5pt;line-height: 12pt;text-align: justify;">пароли не должны храниться в открытом виде;</p></li><li><p style="padding-left: 49pt;text-indent: -5pt;line-height: 12pt;text-align: justify;">приложение должно предоставлять надежную процедуру изменения пароля;</p></li><li><p style="padding-left: 5pt;text-indent: 35pt;text-align: right;">во время выполнения критических действий должна запрашиваться повторная аутентификация. RFC 7235 [2] описывает протокол аутентификации для HTTP на основе логина и пароля. При обращении неавторизованного клиента к защищенному ресурсу, сервер отправляет ответ &quot;401&quot; и добавляет в заголовок описание схемы аутентификации целевого ресурса. Получив такой ответ, клиент запрашивает у пользователя логин и пароль и отправляет эти параметры серверу в поле Authorisation. Сервер проводит аутентификацию пользователя по полученным данным. Далее поле Authorisation добавляется ко всем запросам на данный сервер. Описанный обмен данными должен проходить с</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">использованием протокола TLS, так как эта схема не обеспечивает защиту пользовательских данных.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Часто при аутентификации по паролю используются токены. После аутентификации по паролю сервер генерирует некоторую информацию – токен (обычно на основе идентификатора сессии или данных пользователя) и отправляет клиенту. К последующим запросам пользователя автоматически добавляется токен, на основе которого сервер проводит авторизацию. Для усиления безопасности токен может быть подписан и зашифрован сервером и иметь срок действия. Данный подход позволяет</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">отказаться от передачи пользовательских данных при каждом запросе и даже в случае перехвата токена злоумышленник сможет использовать его только в текущей сессии.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Более безопасным подходом к аутентификации является использование системы PKI (инфраструктура открытых ключей).</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Основными компонентами PKI системы являются центр сертификации и пользователи. Пользователи взаимодействуют между собой, используя сертификаты, выданные центром сертификации. Понятие сертификатов определено в RFC5280 [3] (стандарт X.509). Для обеспечения аутентификации на основе сертификатов используются криптографические алгоритм с открытым ключом. Сертификат представляет собой набор данных, идентифицирующий владельца, а также его открытый ключ.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Для использовании на территории России RFC 4491 описывает сертификат, использующий российские криптографические алгоритмы GOST R 34.10-94, GOST R 34.10-2001, GOST R 34.11-94. [4]</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Далее описан общий принцип аутентификации на основе сертификатов. Допустим есть участники информационного обмена А и В и центр сертификации ЦС. А генерирует открытый и закрытый ключи и получает сертификат у ЦС, содержащий открытый ключ А. А отправляет В сертификат. В проверяет подпись сертификата с помощью открытого ключа ЦС. После этого В может передавать данные, шифруя их с помощью открытого ключа А, содержащегося в сертификате. При этом центр сертификации должен пользоваться доверием у обоих участников информационного обмена.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">На практике обычно используются иерархические PKI системы, состоящие из множества пользователей и центров сертификации. Центры сертификации создают иерархию, где нижестоящие центры доверяют вышестоящим. Вышестоящие ЦС выдают сертификаты нижестоящим. Корневым в этой структуре является головной центр сертификации, который сам подписывает себе сертификат. Пользователи, желающие обменяться информацией, могут не принадлежать одному и тому же центру сертификации. В таком случае пользователь А не может доверять сертификату пользователя В, выданному неизвестным ЦС. Для решения этой проблемы необходимо построить путь сертификации от проверяемого сертификата до любого из доверенных центров. Например, пользователь А пытается проверить сертификат пользователя Е. А доверят центру сертификации Б. Б подписал сертификат В, В подписал сертификат Г, а Г подписал сертификат Е. Так как существует цепь доверия от Б к Е(Б -&gt;В-&gt;Г-</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">&gt;Е) пользователь А может доверять сертификату пользователя Е.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Сертификат может быть отозван. В таком случае он помещается в CertificateRevocationList (список аннулированных сертификатов).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Государственные стандарты в области аутентификации</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 35pt;text-align: justify;">Стандарт аутентификации описывает ГОСТ Р ИСО/МЭК 9594-8-98 — Основы аутентификации [5]. Данный ГОСТ описывает 2 варианта аутентификации: простая на основе пароля и строгая, использующая ассиметричные криптографические алгоритмы. Простая аутентификация предназначена в основном для локального использования.</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 11pt;text-align: justify;">Простая аутентификация может быть выполнена несколькими способами:</p></li><li><p style="padding-left: 47pt;text-indent: -5pt;text-align: justify;">передача имени пользователя и пароля в открытом виде получателю для проверки;</p></li><li><p style="padding-left: 47pt;text-indent: -5pt;line-height: 12pt;text-align: justify;">передача хэша от имени пользователя, пароля и некоторой дополнительной информации;</p></li><li><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">передача информации, описанной в предыдущем пункте, вместе со случайным числом и/или отметкой времени после применения однонаправленной функции.</p></li></ul><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Второй и третий способы представлены на рисунке 1.Эти способы простой аутентификации обеспечивают защиту передаваемых данных.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 136pt;text-indent: 0pt;text-align: left;"><span><img width="257" height="121" alt="ГОСТ Р ИСО/МЭК 9594-8-98 Информационная технология (ИТ). Взаимосвязь открытых систем. Справочник. Часть 8. Основы аутентификации" title="ГОСТ Р ИСО/МЭК 9594-8-98 Информационная технология (ИТ). Взаимосвязь открытых систем. Справочник. Часть 8. Основы аутентификации" src="elibrary_43124455_98620889_files/Image_001.jpg"/></span></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: center;">Рисунок 1 – Простая защищенная аутентификация</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Здесь А - имя пользователя, t - отметка времени, q^ - случайные числа, f1 и f2 однонаправленные функции.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Незащищенные пароли предполагают минимальную степень безопасности и не могут рассматриваться как основа услуг аутентификации.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 35pt;text-align: justify;">Строгая аутентификация основана на использовании ассиметричных криптографических систем. Пользователи идентифицируются на основе владения личным ключом. Для того, чтобы проверить, обладает ли собеседник личным ключом другого пользователя, необходимо обладать ключом общего пользования этого пользователя. Для того, чтобы проверить принадлежность открытых ключей пользователей, должна существовать непрерывная цепочка доверительных точек. Для построения такой цепочки выполняется поиск общей точки доверия. Уполномоченный по сертификации (аналог центра сертификации PKI системы), далее УС, создает сертификат пользователя, подписывая следующую информацию: имя пользователя, ключ общего пользования, и, опционально, уникальный идентификатор. Для того, чтобы любой пользователь имел доступ к ключу общего пользования УС, запись каждого уполномоченного по сертификации содержит сертификаты двух типов. Первый тип – это срочные сертификаты, созданные другими уполномоченными по сертификации. Второй тип – это реверсивные сертификаты. Сертификаты этого типа уполномоченный по сертификации выдает себе сам.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Список сертификатов, необходимый для того, чтобы пользователь мог получить общий ключ другого пользователя, называется &quot;путь сертификации&quot;. Каждый элемент такого списка является сертификатом уполномоченного по сертификации следующего элемента в списке.В общем случае, перед выполнением аутентификации строится путь сертификации. Далее описаны процедуры строгой аутентификации.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Однонаправленная аутентификация использует одну передачу информации от пользователя А пользователю В и позволяет установить подлинность участников обмена, происхождение и получателей маркера аутентификации, целостность и новизну маркера аутентификации.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">В двунаправленной аутентификации используется дополнительный ответ от В к А. Двунаправленная аутентификация дополнительно устанавливает, что маркер аутентификации ответа был сгенерирован В и предназначен для А, целостность и новизну маркера аутентификации пользователя В.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">При трехнаправленной аутентификации добавляется дополнительная передача от А к В. Трехнаправленная аутентификация устанавливает те же свойства, что двухнаправленная, но не нуждается в проверке меток времени.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Для каждой из описываемых ниже процедур аутентификации предполагается, что сторона А выполнила проверку всех сертификатов в пути аутентификации.</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">При однонаправленной аутентификации выполняются следующие шаги:</p><ol id="l2"><li><p style="padding-left: 41pt;text-indent: -18pt;text-align: left;">А создает rA (неповторяющийся номер), который используется для обнаружения повторных угроз и предотвращения подделок;</p></li><li><p style="padding-left: 41pt;text-indent: -17pt;text-align: left;">А посылает к В сообщение, содержащее следующие данные:</p><ul id="l3"><li><p style="padding-left: 69pt;text-indent: -5pt;line-height: 12pt;text-align: left;">путь сертификации от В к А (В<span class="s2"></span>А)</p></li><li><p style="padding-left: 69pt;text-indent: -5pt;line-height: 11pt;text-align: left;">отметка времени (tA), содержащая дату истечения срока действия маркера;</p></li><li><p style="padding-left: 69pt;text-indent: -5pt;line-height: 12pt;text-align: left;">rA;</p></li></ul></li></ol><ul id="l4"><li><p style="padding-left: 47pt;text-indent: -5pt;text-align: left;">имя или численный идентификатор В;</p></li><li><p style="padding-left: 47pt;text-indent: -5pt;line-height: 12pt;text-align: left;">данные, аутентификация отправителя которых обеспечивается с помощью подписи;</p></li><li><p style="padding-left: 5pt;text-indent: 35pt;text-align: left;">данные, в последствии используемые в качестве личного ключа, зашифрованные с помощью открытого ключа B.</p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;">На рисунке 2 представлена структура передаваемого сообщения.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="280" height="14" alt="image" src="elibrary_43124455_98620889_files/Image_002.jpg"/></span></p><p style="padding-top: 2pt;padding-left: 81pt;text-indent: 0pt;text-align: center;">Рисунок 2 – Структура сообщения при однонаправленной аутентификации</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 27pt;text-indent: 0pt;text-align: justify;">Здесь А{данные} означает данные, подписанные А. Пользователь В выполняет следующие действия:</p></li><li><p style="padding-left: 49pt;text-indent: -8pt;line-height: 12pt;text-align: justify;">получает публичный ключ А, проверяет, что срок сертификата пользователя А не истек;</p></li><li><p style="padding-left: 49pt;text-indent: -8pt;line-height: 12pt;text-align: justify;">проверяет целостность полученной информации;</p></li><li><p style="padding-left: 49pt;text-indent: -8pt;line-height: 12pt;text-align: justify;">проверяет, что информация предназначена для передачи ему;</p></li><li><p style="padding-left: 49pt;text-indent: -8pt;text-align: justify;">проверяет, что отметка времени имеет значение &quot;текущее&quot;;</p></li><li><p style="padding-left: 49pt;text-indent: -8pt;line-height: 12pt;text-align: justify;">может проверить, что rA повторно не использован.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Двунаправленная аутентификация на первых этапах происходит так же, как и однонаправленная, но после получения маркера от А, В отправляет сообщение, содержащее метку времени tB, имя или численный идентификатор A, rA, данные, аутентификация отправителя которых обеспечивается с помощью подписи и данные, которые могут использоваться, в качестве личного ключа (зашифрованные открытым ключом B). На рисунке 3 представлена структура сообщения, передаваемого от В к А.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 156pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span><img width="235" height="12" alt="image" src="elibrary_43124455_98620889_files/Image_003.jpg"/></span></p><p style="padding-top: 8pt;padding-left: 81pt;text-indent: 0pt;text-align: center;">Рисунок 3 - Структура сообщения, передаваемого от В к А</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 35pt;text-align: justify;">Пользователь А проверяет целостность полученной информации, проверяет, что он является получателем, проверяет, что отметка времени имеет значение &quot;текущее&quot;. Также А может проверить, что rA не используется повторно.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">При трехнаправленной аутентификации происходит передача сообщений от А к В и от В к А как в случае двунаправленной аутентификации, за исключением того, что метки времени tA и tB могут быть нулевыми и не должны проверяться. Затем пользователь А проверяет соответствие переданного rA полученному и передает B маркер аутентификации, представленный на рисунке 4.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 220pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="61" height="14" alt="image" src="elibrary_43124455_98620889_files/Image_004.jpg"/></span></p><p style="padding-top: 4pt;padding-left: 81pt;text-indent: 0pt;text-align: center;">Рисунок 4 – Повторный маркер аутентификации, передаваемый от А к В</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 27pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">В проверяет целостность полученной информации и сверяет полученный и отправленный rВ.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Ранее также использовались американские стандарты аутентификации FIPS 113 — COMPUTER DATA AUTHENTICATION и FIPS 196. Стандарт FIPS 113 описывал аутентификацию данных на основе алгоритма DES и был отозван в 2008 году как не удовлетворяющий текущим требованиям безопасности. Стандарт FIPS 196 описывал аутентификацию, основанную на открытом ключе, и был отозван в 2015 году по той же причине.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Действующим стандартом остается алгоритм HMAC (FIPS PUB 198) [6]. Этот алгоритм описывает процедуру подписи данных на основе общего ключа.</p><p style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Алгоритм HMAC можно описать следующей формулой, представленной на рисунке 5.</p><p style="padding-left: 132pt;text-indent: 0pt;text-align: left;"><span><img width="299" height="38" alt="image" src="elibrary_43124455_98620889_files/Image_005.jpg"/></span></p><p style="padding-top: 3pt;padding-left: 81pt;text-indent: 0pt;text-align: center;">Рисунок 5 – Формирование подписи на основе HMAC</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Здесь H() обозначает применение некоторой хэш-функции, text - подписываемые данные, К– ключ (дополненный или урезанный до размера блока), opad – блок вида (0x5c, 0x5c … 0x5c), ipad – блок вида (0x36, 0x36 … 0x36). Ключи, длина которых меньше половины длины хэша, возвращаемого H, считаются небезопасными.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Реализация HMAC является обязательной для IPsec. Также алгоритм используется в протоколе TLS. Главный недостаток HMAC – требуются две доверяющие друг другу стороны (знающие общий ключ).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Описание современных протоколов аутентификации</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 35pt;text-align: justify;">Протокол TLS использует для аутентификации пользователей сертификаты, а для аутентификации и сохранения целостности данных HMAC.TLS ориентирован на обеспечение безопасности соединения в клиент – серверных приложениях.</p><p style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">Процедура аутентификации и согласования ключей TLS состоит из следующих шагов:</p><ul id="l5"><li><p style="padding-left: 69pt;text-indent: -5pt;text-align: left;">установление TCP соединения между клиентом и сервером;</p></li><li><p style="padding-left: 41pt;text-indent: 21pt;text-align: left;">клиент отправляет на сервер спецификацию, содержащую версию протокола, которую он хочет использовать, поддерживаемые алгоритмы шифрования и хеш-функции;</p></li><li><p style="padding-left: 41pt;text-indent: 21pt;text-align: left;">сервер утверждает версию используемого протокола, способ шифрования, прикрепляет свой сертификат и отправляет ответ клиенту, также сервер может запросить сертификат клиента;</p></li><li><p style="padding-left: 41pt;text-indent: 21pt;text-align: left;">клиент проверяет сертификат сервера и инициирует обмен ключами с помощью алгоритма RSA или Диффи-Хеллмана (в зависимости от установленных параметров);</p></li><li><p style="padding-left: 41pt;text-indent: 21pt;text-align: left;">сервер обрабатывает сообщение клиента, сверяет MAC, и отправляет клиенту сообщение (‘Finished’) в зашифрованном виде;</p></li><li><p style="padding-left: 69pt;text-indent: -5pt;line-height: 12pt;text-align: left;">клиент расшифровывает сообщение и сверяет MAC.</p></li></ul></li></ul><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Предпочтительным считается согласование ключа по алгоритму Диффи-Хеллмана, так как в этом случае ключ не передается между клиентом и сервером.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Протокол Kerberos использует описанный ниже алгоритм. Для получения доступа к какому-либо сервису клиент направляет запрос в службу KDC, которая хранит информацию об учетных записях всех клиентов сети и общие с этими клиентами долговременные ключи шифрования. Запрос содержит следующую информацию: идентификатор клиента, метку времени и идентификатор сервера. Служба KDC генерирует сеансовый ключ, действительный на протяжении некоторого времени. KDC отправляет клиенту ответ, зашифрованный с помощью долговременного ключа общего с клиентом. Ответ содержит сеансовый ключ, идентификатор сервиса, время жизни ключа и мандат. Мандат содержит данные о клиенте, метку времени и сеансовый ключ. Мандат шифруется долговременным ключом, общим с сервером. Получив ответ KDC, клиент извлекает из него мандат и свою копию сеансового ключа. После этого клиент посылает серверу сообщение, состоящее из мандата (который зашифрован долговременным ключом сервера), и своего аутентификатора, зашифрованного с помощью сеансового ключа. Сервер с</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">помощью своего долговременного секретного ключа расшифровывает сеансовый мандат и извлекает из него сеансовый ключ и данные о клиенте. С помощью полученного сеансового ключа сервер расшифровывает аутентификатор клиента и сверяет с информацией, содержавшейся в мандате. Клиент может потребовать у сервера проведения взаимной аутентификации. В таком случае сервер шифрует с помощью сеансового ключа метку времени из аутентификатора клиента и пересылает её клиенту.</p><p style="padding-left: 5pt;text-indent: 35pt;text-align: justify;">Также для Kerberos существует расширение PKI NIT, позволяющее проводить описанную процедуру с использованием ассиметричного шифрования. В этом случае появляются такие отличия:</p><ol id="l6"><li><p style="padding-left: 41pt;text-indent: -17pt;text-align: justify;">При создании запроса к KDC указывается, что будет использоваться асимметричное шифрование. Сам запрос подписывается и кроме стандартной информации содержит сертификат пользователя.</p></li><li><p style="padding-left: 41pt;text-indent: -17pt;text-align: justify;">Получив запрос, KDC проверяет достоверность сертификата и электронную подпись. После этого KDC проверяет локальное время, присланное в запросе (для защиты от повторов).</p></li><li><p style="padding-left: 41pt;text-indent: -17pt;text-align: justify;">После проверки подлинности клиента, KDC формирует ответ, зашифрованный открытым ключом пользователя. Кроме того ответ подписывается и содержит сертификат KDC.</p></li><li><p style="padding-left: 41pt;text-indent: -18pt;text-align: justify;">Получив ответ, пользователь проверяет подпись KDC и расшифровывает свой сеансовый ключ.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Выводы</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 35pt;text-align: justify;">Был проведен обзор существующих алгоритмов аутентификации, были рассмотрены стандарты в области аутентификации и принципы работы распространенных протоколов аутентификации. Можно сделать вывод, что наиболее используемыми способами аутентификации являются аутентификация по паролю и аутентификация на основе сертификатов. Эти виды аутентификации используются современных протоколах аутентификации и описаны в государственных стандартах. При этом аутентификация на основе сертификатов является более защищенной, но при этом боле сложна, чем аутентификация по паролю и требует наличия инфраструктуры.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Список источников</p><ol id="l7"><li><p style="padding-top: 5pt;padding-left: 55pt;text-indent: -21pt;text-align: justify;">Mostcommonpasswords [Электронныйресурс]. – Режим доступа: https://keepersecurity.com/public/Most-Common-Passwords-of-2016-Keeper-Security-Study.pdf</p></li><li><p style="padding-left: 55pt;text-indent: -21pt;text-align: justify;">Hypertext Transfer Protocol (HTTP/1.1): Authenticationpasswords [Электронныйресурс]. – Режим доступа: https://tools.ietf.org/html/rfc7235</p></li><li><p style="padding-left: 55pt;text-indent: -21pt;text-align: justify;"><a href="http://www.ietf.org/rfc/rfc5280.txt" class="a" target="_blank">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile[Электронныйресурс]. – Режимдоступа: https:/</a><a href="http://www.ietf.org/rfc/rfc5280.txt" target="_blank">/www.ietf.org/rfc/rfc5280.txt</a></p></li><li><p style="padding-left: 55pt;text-indent: -21pt;text-align: justify;">Using the GOST R 34.10-94, GOST R 34.10-2001, and GOST R 34.11-94 Algorithms with the Internet X.509 Public Key Infrastructure [Электронныйресурс]. – Режимдоступа: https://tools.ietf.org/html/rfc4491</p></li><li><p style="padding-left: 55pt;text-indent: -21pt;text-align: justify;"><a href="http://docs.cntd.ru/document/1200028710" class="a" target="_blank">ГОСТ Р ИСО/МЭК 9594-8-98 Информационная технология [Электронный ресурс]. –Режим доступа: </a><a href="http://docs.cntd.ru/document/1200028710" target="_blank">http://docs.cntd.ru/document/1200028710</a></p></li><li><p style="padding-left: 55pt;text-indent: -21pt;text-align: justify;">HMAC: Keyed-Hashing for Message Authentication [Электронный ресурс]. – Режимдоступа:https://tools.ietf.org/html/rfc2104.html</p></li><li><p style="padding-left: 55pt;text-indent: -21pt;text-align: justify;">The Transport Layer Security (TLS) Protocol [Электронный ресурс]. – Режимдоступа: https://tools.ietf.org/html/rfc5246</p></li><li><p style="padding-left: 55pt;text-indent: -21pt;text-align: justify;">The Kerberos Network Authentication Service [Электронныйресурс]. – Режим доступа: https://tools.ietf.org/html/rfc1510</p></li></ol></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 34pt;text-indent: 0pt;text-align: justify;">Грищенко О.С., Чернышова А.В. Обзор алгоритмов аутентификации в распределенных программных системах. <span class="s3">Представлен обзор существующих алгоритмов аутентификации, используемых в современных распределенных системах. Описаны стандарты в данной области. Рассмотрен принцип работы распространенных протоколов аутентификации.</span></h2><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 34pt;text-indent: 0pt;text-align: justify;">Ключевые слова: <span class="s3">распределенная система, аутентификация, TLS, сертификат, однонаправленная аутентификаци, RSA, Kerberos</span></h2><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 34pt;text-indent: 0pt;text-align: justify;">Grichenco O.S., Chernyshova A.V. Overview of authentication algorithms in distributed software systems. <span class="s3">An overview of the existing authentication algorithms used in modern distributed systems is presented. The standards of authentication are described. The principle of operation of authentication protocols is considered.</span></h2><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 34pt;text-indent: 0pt;text-align: justify;">Keywords<span class="p">: </span><span class="s3">distributed system, authentication, TLS, certificate, unidirectional authentication, RSA, Kerberos</span></h2></body></html>
